
'''
######################################################################
Mixed Integer Linear problem for Hybrid Off-grid MicrogidMetoria of 
Sodenfiarden modeled using PulP and solaved by GUROBI solver.
######################################################################
'''
# IMPORTING LIBRARIES.

from src.functions.fuel_consumption import fuelCon
from src.functions.load_window import lwd 
import numpy as np
import pandas as pd
from pulp import *
import json
import csv



### Introducing problem parameters.
Q_max = 10                                                    # maximal capacity stored on battery.
Q_0 = 0.1*Q_max                                               # inital capacity stored on battery.
Q_final = 0.2*Q_max                                           # Final capacity stored on the battery. 
eff_to_bss = 0.9                                              # battery charging efficiency.
eff_from_bss = 0.9                                            # battery transfer efficiency. 
P_max = 15                                                    # max output from gen set A.
P_min = 0                                                     # min output from gen set A.        
dt = 1                                                        # simulation time step dt.
t_max = 10                                                    # time span for simulation = t_max hours.
t = np.atleast_2d(np.arange(0,t_max,dt)).T.conj()             # time scale in hours.
n = len(t)                                                    # number of time steps.
m = 1                                                         # number of Gensets used on the trip, 1 is used.
fc_offset = 190                                               # genset j fuel consumption when no power gnerated (p=0) in g/h.
V_steps = [x for x in range(0,n)]                             # Time steps vector. 
V_steps_z = V_steps[:-1]                                      # Time steps vector without the final step. 
Q_h = 135000                                                  # Estimated heat loss when temp drops. 1 kJ/h = 0.0002777778 kW
T_H = 21                                                      # Inside temperature (°C) (barn temperature). 
S_pv30 = 24                                                   # Solar PV modules surface. 


Irr_list = []
df = pd.read_csv('Irr_sol.csv')
for i in df.iloc[5,:]: 
    Irr_list.append(float(i))
    Irr_sol_dict = dict(zip(V_steps, Irr_list))

print(Irr_list)
print(Irr_sol_dict)


P_pv30 = {k:Irr_sol_dict[k] * S_pv30 for k in V_steps} # = Irr_sol[k]*S_pv30 for k in V_steps
print(P_pv30)
P_pv60 = {0:1.2, 1:1.1, 2:0.9, 3:0.8, 4:1.6, 5:1.1, 6:1.6, 7:1.8, 8:1.5, 9:2}
P_wind = {0:1, 1:1.9, 2:3, 3:0.8, 4:0.9, 5:10, 6:8.8, 7:0.9, 8:1.3, 9:2}
P_pv30_max = 2                                                # (Irr_sol[k]*S_pv30 for k in V_steps)  Maximal power generated by Solar PV modules tilted by 30° (for maximal irradiance (W/m^2).
P_pv30_min = 0                                                # Minimal power generated by Solar PV modules tilted by 30° (at night irradiance = 0 W/m^2).
P_pv60_max = 2                                                # (Irr_sol[k]*S_pv60 for k in V_steps)  Maximal power generated by Solar PV modules tilted by 60° (for maximal irradiance (W/m^2).
P_pv60_min = 0                                                # Minimal power generated by Solar PV modules tilted by 60° (at night irradiance = 0 W/m^2).
P_wind_max = 11                                               # (1/2*V_wind[k]*Cp*rho*math.pi*R**2 for k in V_steps) Maximal power generated by the wind turbine (cut-out wind speed (kwh).  P = 0.5 Cp ρ π R2 V3
P_wind_min = 0	                                              # Minimal power generated by the wind turbine (cut-in wind speed (kwh).
P_hp_max = 1.1                                                # (Q_h / 1 / (1 - T_L[k] / T_H) for k in V_steps) Maximal power transferred to Meteoria barn’s heat pumps (kwh).
P_hp_min = 	0                                                 # Minimal power transferred to Meteoria barn’s heat pumps (kwh).
P_sh_max =  5.1	                                              # Maximal power transferred to the space heater (kwh).
P_sh_min =	0                                                 # Minimal power transferred to the space heater (kwh).
P_bio_max =	1.2                                               # Maximal power generated by biomeiler compost heater (kwh).
P_bio_min =	0                                                 # Minimal power generated by biomeiler compost heater (kwh).
P_wh_max = 6                                                  # Maximal power transferred to water tank heater (kwh).
P_wh_min = 0	                                                # Minimal power transferred to water tank heater (kwh).
P_stnb_max = 3                                                # Maximal standby power to keep essential equipment on standby mode (kwh).
P_stnb_min = 3	                                              # Minimal standby power to keep essential equipment on standby mode (kwh).     
L = lwd (5, 3, 5,                                             # Typical Power requirement window.
                5, 10, 5,
                2, 1.5, 10,
                1.5, 2.5, 30,
                0, 5, 20, 30)                                 
'''
L = lwd (10, 5, 8,                                          # Typical Power requirement window.
                3, 2, 9,
                4, 9, 6,
                3, 7, 30,
                0, 5, 20, 30)   
'''


### Creating the problem variable. 
Optim = LpProblem('Energy_Opt',LpMinimize)


### Slope, intercept and maximum fuel bound calculation.
a_j = (fuelCon(0.9*P_max, P_max) - fuelCon(0.2*P_max, P_max)) /(0.9*P_max) #slope.
b_j = fuelCon(0.2*P_max, P_max) - a_j*0.2*P_max #Intercept.
FOC_max = fuelCon(0.9*P_max,P_max) # Max fuel bound.


### Setting-up decision Variables.
Q_bss = LpVariable.dicts("Q_bss", V_steps, lowBound=0.2*Q_max, upBound=Q_max, cat=LpContinuous)  # Battery charge at time step k.
P_from_bss = LpVariable.dicts("P_from_bss", V_steps, lowBound=P_min, cat=LpContinuous) # Power transfered from the battery to the load.
P_pv30 = LpVariable.dicts("P_pv30", V_steps, lowBound=P_pv30_min, upBound=P_pv30_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
P_pv60 = LpVariable.dicts("P_pv60", V_steps, lowBound=P_pv60_min, upBound=P_pv60_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
P_wind = LpVariable.dicts("P_wind", V_steps, lowBound=P_wind_min, upBound=P_wind_max, cat=LpContinuous) # Power from wind turbine.
P = LpVariable.dicts("P", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Power generated by the Genset A.
P_res = LpVariable.dicts("P_res", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Total Power from RES.
P_load = LpVariable.dicts("P_load", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous) # Power transfered from the Genset A to the load at time step k.
P_stnb = LpVariable.dicts("P_stnb", V_steps, lowBound=P_stnb_min, upBound=P_stnb_max, cat=LpContinuous) # Standby power.
P_to_sh = LpVariable.dicts("P_to_sh", V_steps, lowBound=P_sh_min, upBound=.9*P_max, cat=LpContinuous) # Power to space heater (excess heat (kw). 
P_to_wh = LpVariable.dicts("P_to_wt", V_steps, lowBound=P_wh_min, upBound=.9*P_max, cat=LpContinuous) # Power to water tank heater.
P_to_hp = LpVariable.dicts("P_to_hp", V_steps, lowBound=P_hp_min, upBound=.9*P_max, cat=LpContinuous) # Power to heat pumps.
P_bio	= LpVariable.dicts("P_bio", V_steps, lowBound=P_bio_min, upBound=P_bio_max, cat=LpContinuous) # Power from biomeiler compost heater. 
Z =  LpVariable.dicts("Z", V_steps_z, lowBound=0, upBound=1, cat=LpInteger) # Aditional cost fuel oil consumption when starting Genset j.
FOC = LpVariable.dicts("FOC", V_steps, lowBound=0, upBound=FOC_max, cat=LpContinuous) # Fuel oil consumption of genset j.
P_to_bss =  LpVariable.dicts("P_to_bss", V_steps, lowBound=P_min, cat=LpContinuous) 
Y_to_bss = LpVariable.dicts("Y_to_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter to charge the battery at time step k. 
Y_from_bss = LpVariable.dicts("Y_from_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Battery selecter to transfert to the Genset j st time step k.
Y = LpVariable.dicts("Y", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter : turned on : Y=1, turned off : Y=0.
Y_bio = LpVariable.dicts("Y_bio", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of biomeiler.
Y_sh =	LpVariable.dicts("Y_sh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of space heater.
Y_hp = LpVariable.dicts("Y_hp", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of heat pumps.
Y_wh = LpVariable.dicts("Y_wh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of water heater.
Y_wind = LpVariable.dicts("Y_wind", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of wind turbine.
Y_pv30 = LpVariable.dicts("Y_pv30", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 30°.
Y_pv60 = LpVariable.dicts("Y_pv60", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 60°.
Y_res = LpVariable.dicts("Y_res", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state RES.


### Setting-up the objective function.
FC = sum(FOC[k] for k in V_steps) * dt/1000  # sum of the fuel oil comsumption for all gensets over all k steps.
L_added_cost = sum(Z[i] for i in V_steps_z)  # Sum of all of the additional costs including starting costs. 
Optim += lpSum (FC + L_added_cost), " Minimization fuel oil consumption objective " 
print(FC)


### Setting-up problem constraints.

for k in V_steps:

  # Fuel oil consumption constraint.
  Optim += FOC[k] == P[k]*a_j + b_j - fc_offset*Y[k]     
  Optim += P_res[k] == P_pv30[k] + P_pv60[k] + P_wind[k] 
  Optim += P_res[k] >= P_min * Y_res[k]
  Optim += Y_res[k] >= 1
  Optim += P_load[k] + eff_from_bss*P_from_bss[k] + P_res[k] >= L[k] 
  Optim += P_load[k] == P_to_hp[k] + P_to_sh[k]
  Optim += P_load[k] + P_to_bss[k] + P_stnb[k] + P_to_wh[k] <= P[k] + P_res[k]
  Optim += P_stnb[k] == P_stnb_max
  Optim += P_to_hp[k] >= (Q_h * (1 - (25 /T_H))) * Y_hp[k]
  Optim += P_to_hp[k] <= P_hp_max * Y_hp[k]
  Optim += P_bio[k] <= P_bio_max * Y_bio[k]
  Optim += P_to_wh[k] <= 0.9*P_max * Y_wh[k]
  Optim += P_to_sh[k] <= 0.9*P_max * Y_sh[k]
  Optim += P[k]  <= P_max * Y[k]
  Optim += P[k]  >= P_min * Y[k]
  Optim += Y[k] + Y_res[k] >= 0
  Optim += Y[k] <= 1
  Optim += P_to_bss[k] <= eff_to_bss * P_max * Y_to_bss[k]
  Optim += P_from_bss[k] <= eff_from_bss * P_max * Y_from_bss[k]
  Optim += Y_to_bss[k] + Y_from_bss[k]  <= 1
  if k == V_steps[0] :                                            
    Optim += Q_bss[k] == Q_0 + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt
  else :  
    Optim += Q_bss[k] == Q_bss[k-1] + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt

for k in range(V_steps[0], V_steps[-1]): 
  Optim += Z[k] >= Y[k + 1] - Y[k] 
Optim += Q_bss[V_steps[-1]] == Q_final


### Solving the problem.
status = Optim.solve(GUROBI())


### Optimization status.
LpStatus[status]

# PRINTING THE LP OPTIMAL SOLUTION.
for v in Optim.variables():
    print(v.name, "=", v.varValue)


### Calculating the optimized fuel comsumption.
print("Actual total fuel comsumption:", value(Optim.objective),'kg') 
print('Optimization done!')

