import paho.mqtt.client as mqtt #importing the client 
import time #importing time 
from time import sleep
import access_key
from datetime import datetime
from src.functions.fuel_consumption import fuelCon
from src.functions.load_window import lwd 
from queue import Queue
import json

import pandas as pd
import numpy as np
from pulp import *


# Optimizer params 



### Introducing problem parameters.
Q_max = 10                                                    # maximal capacity stored on battery.
Q_0 = 0.1*Q_max                                               # inital capacity stored on battery.
Q_final = 0.2*Q_max                                           # Final capacity stored on the battery. 
eff_to_bss = 0.9                                              # battery charging efficiency.
eff_from_bss = 0.9                                            # battery transfer efficiency. 
P_max = 3000                                          # max output from gen set A.
P_min = 0                                                     # min output from gen set A.        
dt = 1                                                        # simulation time step dt.
t_max = 10                                                    # time span for simulation = t_max hours.
t = np.atleast_2d(np.arange(0,t_max,dt)).T.conj()             # time scale in hours.
n = len(t)                                                    # number of time steps.
m = 1                                                         # number of Gensets used on the trip, 1 is used.
fc_offset = 190                                               # genset j fuel consumption when no power gnerated (p=0) in g/h.
V_steps = [x for x in range(0,n)]                             # Time steps vector. 
P_pub = [0 for x in range(0,n)] 
V_steps_z = V_steps[:-1]                                      # Time steps vector without the final step. 
Q_h = 135000                                                  # Estimated heat loss when temp drops. 1 kJ/h = 0.0002777778 kW
T_H = 21                                                      # Inside temperature (°C) (barn temperature). 
S_pv30 = 24                                                   # Solar PV modules surface. 


Irr_list = []
df = pd.read_csv('Irr_sol.csv')
for i in df.iloc[-1,:]: 
    Irr_list.append(float(i))
    Irr_sol_dict = dict(zip(V_steps, Irr_list))

print(Irr_list)
print(Irr_sol_dict)
print('last row', df.iloc[-1,:])

P_pv30 = {k:Irr_sol_dict[k] * S_pv30 for k in V_steps}        # = Irr_sol[k]*S_pv30 for k in V_steps
print('P_pv30 = ',P_pv30)



P_wind = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0}
#P_pv30 = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0}
P_pv60 = {0:0, 1:3, 2:0, 3:0, 4:4, 5:0, 6:1.5, 7:0, 8:0, 9:0}
#P_wind = {k:1/2*V_wind[k]*Cp*rho*math.pi*R**2 for k in V_steps) # Power generated by the wind turbine (cut-out wind speed (kwh).  P = 0.5 Cp ρ π R2 V3
P_pv30_max = 2                                                # (Irr_sol[k]*S_pv30 for k in V_steps)  Maximal power generated by Solar PV modules tilted by 30° (for maximal irradiance (W/m^2).
P_pv30_min = 0                                                # Minimal power generated by Solar PV modules tilted by 30° (at night irradiance = 0 W/m^2).
P_pv60_max = 2                                                # (Irr_sol[k]*S_pv60 for k in V_steps)  Maximal power generated by Solar PV modules tilted by 60° (for maximal irradiance (W/m^2).
P_pv60_min = 0                                                # Minimal power generated by Solar PV modules tilted by 60° (at night irradiance = 0 W/m^2).
P_wind_max = 11                                               # (1/2*V_wind[k]*Cp*rho*math.pi*R**2 for k in V_steps) Maximal power generated by the wind turbine (cut-out wind speed (kwh).  P = 0.5 Cp ρ π R2 V3
P_wind_min = 0	                                              # Minimal power generated by the wind turbine (cut-in wind speed (kwh).
P_hp_max = 1.1                                                # (Q_h / 1 / (1 - T_L[k] / T_H) for k in V_steps) Maximal power transferred to Meteoria barn’s heat pumps (kwh).
P_hp_min = 	0                                                 # Minimal power transferred to Meteoria barn’s heat pumps (kwh).
P_sh_max =  5.1	                                              # Maximal power transferred to the space heater (kwh).
P_sh_min =	0                                                 # Minimal power transferred to the space heater (kwh).
P_bio_max =	1.2                                               # Maximal power generated by biomeiler compost heater (kwh).
P_bio_min =	0                                                 # Minimal power generated by biomeiler compost heater (kwh).
P_wh_max = 6                                                  # Maximal power transferred to water tank heater (kwh).
P_wh_min = 0	                                                # Minimal power transferred to water tank heater (kwh).
P_stnb_max = 3                                                # Maximal standby power to keep essential equipment on standby mode (kwh).
P_stnb_min = 3	                                              # Minimal standby power to keep essential equipment on standby mode (kwh).     
L = lwd (5, 3, 5,                                             # Typical Power requirement window.
                5, 10, 5,
                2, 1.5, 10,
                1.5, 2.5, 30,
                0, 5, 20, 30)       


# Getting the current date and time
q=Queue()
####

username= access_key.username
password= access_key.password

sub_topic = 'open/meteoria/solarRadiation'
mes = 'Irr_sol'
unit = 'W/m^2'


Irr_list = []
df = pd.read_csv('Irr_sol.csv')
for i in df.iloc[-1,:]: 
    Irr_list.append(float(i))
    Irr_sol_dict = dict(zip(V_steps, Irr_list))


# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code "+str(rc))
    client.subscribe(sub_topic)


data_stream, strg = [], []
#Irr_sol = {}
steps=[k for k in range (0,9)]
def on_message(client, userdata, message): 
    
    global data_stream, strg, Irr_sol

    i=0
    if len(data_stream) < 10 :    
       for j in range(0,9): 
        while i < 1 : 
            log = json.loads(message.payload.decode("utf-8"))
            data_stream.append(log) 
            #Irr_sol = dict(zip(steps, data_stream))
            i+=1
            j+=1
            if len(data_stream) == 10: 
                strg=data_stream
                print('returned list', strg)

                ###############################  OPTIMIZATION ###################################################################

                Irr_list = []
                df = pd.read_csv('Irr_sol.csv')
                for i in df.iloc[-1,:]: 
                    Irr_list.append(float(i))
                    Irr_sol_dict = dict(zip(V_steps, Irr_list))
                P_pv30 = {k:Irr_sol_dict[k] * S_pv30 for k in V_steps} 

                Optim = LpProblem('Energy_Opt',LpMinimize)

                ### Slope, intercept and maximum fuel bound calculation.
                a_j = (fuelCon(0.9*P_max, P_max) - fuelCon(0.2*P_max, P_max)) /(0.9*P_max) #slope.
                b_j = fuelCon(0.2*P_max, P_max) - a_j*0.2*P_max #Intercept.
                FOC_max = fuelCon(0.9*P_max,P_max) # Max fuel bound.


                ### Setting-up decision Variables.
                Q_bss = LpVariable.dicts("Q_bss", V_steps, lowBound=0.2*Q_max, upBound=Q_max, cat=LpContinuous)  # Battery charge at time step k.
                P_from_bss = LpVariable.dicts("P_from_bss", V_steps, lowBound=P_min, cat=LpContinuous) # Power transfered from the battery to the load.
                #P_pv30 = LpVariable.dicts("P_pv30", V_steps, lowBound=P_pv30_min, upBound=P_pv30_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
                #P_pv60 = LpVariable.dicts("P_pv60", V_steps, lowBound=P_pv60_min, upBound=P_pv60_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
                #P_wind = LpVariable.dicts("P_wind", V_steps, lowBound=P_wind_min, upBound=P_wind_max, cat=LpContinuous) # Power from wind turbine.
                P = LpVariable.dicts("P", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Power generated by the Genset A.
                P_res = LpVariable.dicts("P_res", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Total Power from RES.
                P_load = LpVariable.dicts("P_load", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous) # Power transfered from the Genset A to the load at time step k.
                P_stnb = LpVariable.dicts("P_stnb", V_steps, lowBound=P_stnb_min, upBound=P_stnb_max, cat=LpContinuous) # Standby power.
                P_to_sh = LpVariable.dicts("P_to_sh", V_steps, lowBound=P_sh_min, upBound=.9*P_max, cat=LpContinuous) # Power to space heater (excess heat (kw). 
                P_to_wh = LpVariable.dicts("P_to_wt", V_steps, lowBound=P_wh_min, upBound=.9*P_max, cat=LpContinuous) # Power to water tank heater.
                P_to_hp = LpVariable.dicts("P_to_hp", V_steps, lowBound=P_hp_min, upBound=.9*P_max, cat=LpContinuous) # Power to heat pumps.
                P_bio	= LpVariable.dicts("P_bio", V_steps, lowBound=P_bio_min, upBound=P_bio_max, cat=LpContinuous) # Power from biomeiler compost heater. 
                Z =  LpVariable.dicts("Z", V_steps_z, lowBound=0, upBound=1, cat=LpInteger) # Aditional cost fuel oil consumption when starting Genset j.
                FOC = LpVariable.dicts("FOC", V_steps, lowBound=0, upBound=FOC_max, cat=LpContinuous) # Fuel oil consumption of genset j.
                P_to_bss =  LpVariable.dicts("P_to_bss", V_steps, lowBound=P_min, cat=LpContinuous) 
                Y_to_bss = LpVariable.dicts("Y_to_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter to charge the battery at time step k. 
                Y_from_bss = LpVariable.dicts("Y_from_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Battery selecter to transfert to the Genset j st time step k.
                Y = LpVariable.dicts("Y", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter : turned on : Y=1, turned off : Y=0.
                Y_bio = LpVariable.dicts("Y_bio", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of biomeiler.
                Y_sh =	LpVariable.dicts("Y_sh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of space heater.
                Y_hp = LpVariable.dicts("Y_hp", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of heat pumps.
                Y_wh = LpVariable.dicts("Y_wh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of water heater.
                Y_wind = LpVariable.dicts("Y_wind", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of wind turbine.
                Y_pv30 = LpVariable.dicts("Y_pv30", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 30°.
                Y_pv60 = LpVariable.dicts("Y_pv60", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 60°.
                Y_res = LpVariable.dicts("Y_res", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state RES.
                Null = LpVariable.dict("Null", V_steps, lowBound=0, upBound=0,cat=LpBinary) # Reference variable

                ### Setting-up the objective function.
                FC = sum(FOC[k] for k in V_steps) * dt/1000  # sum of the fuel oil comsumption for all gensets over all k steps.
                L_added_cost = sum(Z[i] for i in V_steps_z)  # Sum of all of the additional costs including starting costs. 
                Optim += lpSum (FC + L_added_cost), " Minimization fuel oil consumption objective " 
                print(FC)


                ### Setting-up problem constraints.

                for k in V_steps:

                # Fuel oil consumption constraint.
                    Optim += FOC[k] == P[k]*a_j + (b_j - fc_offset)*Y[k]     
                    Optim += P_res[k] == P_pv30[k] + P_pv60[k] + P_wind[k] 
                    Optim += P_res[k] >= P_min * Y_res[k]
                    Optim += Y_res[k] >= 1
                    Optim += P_load[k] + eff_from_bss*P_from_bss[k] + P_res[k] >= L[k] 
                    Optim += P_load[k] == P_to_hp[k] + P_to_sh[k]
                    Optim += P_load[k] + P_to_bss[k] + P_stnb[k] + P_to_wh[k] <= P[k] + P_res[k]
                    Optim += P_stnb[k] == P_stnb_max
                    Optim += P_to_hp[k] >= (Q_h * (1 - (25 /T_H))) * Y_hp[k]
                    Optim += P_to_hp[k] <= P_hp_max * Y_hp[k]
                    Optim += P_bio[k] <= P_bio_max * Y_bio[k]
                    Optim += P_to_wh[k] <= 0.9*P_max * Y_wh[k]
                    Optim += P_to_sh[k] <= 0.9*P_max * Y_sh[k]
                    Optim += P[k]  <= P_max * Y[k]
                    Optim += P[k]  >= P_min * Y[k]
                    Optim += Y[k] + Y_res[k] >= 0
                    Optim += Y[k] <= 1
                    Optim += P_to_bss[k] <= eff_to_bss * P_max * Y_to_bss[k]
                    Optim += P_from_bss[k] <= eff_from_bss * P_max * Y_from_bss[k]
                    Optim += Y_to_bss[k] + Y_from_bss[k]  <= 1
                    if k == V_steps[0] :                                            
                        Optim += Q_bss[k] == Q_0 + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt
                    else :  
                        Optim += Q_bss[k] == Q_bss[k-1] + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt

                    for k in range(V_steps[0], V_steps[-1]): 
                        Optim += Z[k] >= Y[k + 1] - Y[k] 
                    Optim += Q_bss[V_steps[-1]] == Q_final
                                    
                    ### Solving the problem.
                    status = Optim.solve(GUROBI())


                    ### Optimization status.
                    LpStatus[status]

                    # PRINTING THE LP OPTIMAL SOLUTION.
                    for v in Optim.variables():
                        print(v.name, "=", v.varValue)


                    ### Calculating the optimized fuel comsumption.
                    print("Actual total fuel comsumption:", value(Optim.objective),'g') 
                    print('Optimization done!')

                    ###############################  OPTIMIZATION END ###################################################################

    else : 
        with open("Irr_sol.csv", "a+") as file:
                    mystring = ','.join(map(str,data_stream))
                    file.write("%s" %(mystring)+ "\n")
                    file.close()

        data_stream = []
        i=0
        for j in range(10):
         while i < 1 : 
            log = json.loads(message.payload.decode("utf-8"))
            data_stream.append(log)
            #Irr_sol[j] = data_stream[j] 
            i+=1
            if len(data_stream) == 10:  
                strg=data_stream
                print('returned list:', strg)
                
                ###############################  OPTIMIZATION START ###################################################################

                Irr_list = []
                df = pd.read_csv('Irr_sol.csv')
                for i in df.iloc[-1,:]: 
                    Irr_list.append(float(i))
                    Irr_sol_dict = dict(zip(V_steps, Irr_list))
                P_pv30 = {k:Irr_sol_dict[k] * S_pv30 for k in V_steps} 

                Optim = LpProblem('Energy_Opt',LpMinimize)

                ### Slope, intercept and maximum fuel bound calculation.
                a_j = (fuelCon(0.9*P_max, P_max) - fuelCon(0.2*P_max, P_max)) /(0.9*P_max) #slope.
                b_j = fuelCon(0.2*P_max, P_max) - a_j*0.2*P_max #Intercept.
                FOC_max = fuelCon(0.9*P_max,P_max) # Max fuel bound.


                ### Setting-up decision Variables.
                Q_bss = LpVariable.dicts("Q_bss", V_steps, lowBound=0.2*Q_max, upBound=Q_max, cat=LpContinuous)  # Battery charge at time step k.
                P_from_bss = LpVariable.dicts("P_from_bss", V_steps, lowBound=P_min, cat=LpContinuous) # Power transfered from the battery to the load.
                #P_pv30 = LpVariable.dicts("P_pv30", V_steps, lowBound=P_pv30_min, upBound=P_pv30_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
                #P_pv60 = LpVariable.dicts("P_pv60", V_steps, lowBound=P_pv60_min, upBound=P_pv60_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
                #P_wind = LpVariable.dicts("P_wind", V_steps, lowBound=P_wind_min, upBound=P_wind_max, cat=LpContinuous) # Power from wind turbine.
                P = LpVariable.dicts("P", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Power generated by the Genset A.
                P_res = LpVariable.dicts("P_res", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Total Power from RES.
                P_load = LpVariable.dicts("P_load", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous) # Power transfered from the Genset A to the load at time step k.
                P_stnb = LpVariable.dicts("P_stnb", V_steps, lowBound=P_stnb_min, upBound=P_stnb_max, cat=LpContinuous) # Standby power.
                P_to_sh = LpVariable.dicts("P_to_sh", V_steps, lowBound=P_sh_min, upBound=.9*P_max, cat=LpContinuous) # Power to space heater (excess heat (kw). 
                P_to_wh = LpVariable.dicts("P_to_wt", V_steps, lowBound=P_wh_min, upBound=.9*P_max, cat=LpContinuous) # Power to water tank heater.
                P_to_hp = LpVariable.dicts("P_to_hp", V_steps, lowBound=P_hp_min, upBound=.9*P_max, cat=LpContinuous) # Power to heat pumps.
                P_bio	= LpVariable.dicts("P_bio", V_steps, lowBound=P_bio_min, upBound=P_bio_max, cat=LpContinuous) # Power from biomeiler compost heater. 
                Z =  LpVariable.dicts("Z", V_steps_z, lowBound=0, upBound=1, cat=LpInteger) # Aditional cost fuel oil consumption when starting Genset j.
                FOC = LpVariable.dicts("FOC", V_steps, lowBound=0, upBound=FOC_max, cat=LpContinuous) # Fuel oil consumption of genset j.
                P_to_bss =  LpVariable.dicts("P_to_bss", V_steps, lowBound=P_min, cat=LpContinuous) 
                Y_to_bss = LpVariable.dicts("Y_to_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter to charge the battery at time step k. 
                Y_from_bss = LpVariable.dicts("Y_from_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Battery selecter to transfert to the Genset j st time step k.
                Y = LpVariable.dicts("Y", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter : turned on : Y=1, turned off : Y=0.
                Y_bio = LpVariable.dicts("Y_bio", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of biomeiler.
                Y_sh =	LpVariable.dicts("Y_sh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of space heater.
                Y_hp = LpVariable.dicts("Y_hp", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of heat pumps.
                Y_wh = LpVariable.dicts("Y_wh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of water heater.
                Y_wind = LpVariable.dicts("Y_wind", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of wind turbine.
                Y_pv30 = LpVariable.dicts("Y_pv30", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 30°.
                Y_pv60 = LpVariable.dicts("Y_pv60", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 60°.
                Y_res = LpVariable.dicts("Y_res", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state RES.
                Null = LpVariable.dict("Null", V_steps, lowBound=0, upBound=0,cat=LpBinary) # Reference variable

                ### Setting-up the objective function.
                FC = sum(FOC[k] for k in V_steps) * dt/1000  # sum of the fuel oil comsumption for all gensets over all k steps.
                L_added_cost = sum(Z[i] for i in V_steps_z)  # Sum of all of the additional costs including starting costs. 
                Optim += lpSum (FC + L_added_cost), " Minimization fuel oil consumption objective " 
                print(FC)


                ### Setting-up problem constraints.

                for k in V_steps:

                # Fuel oil consumption constraint.
                    Optim += FOC[k] == P[k]*a_j + (b_j - fc_offset)*Y[k]     
                    Optim += P_res[k] == P_pv30[k] + P_pv60[k] + P_wind[k] 
                    Optim += P_res[k] >= P_min * Y_res[k]
                    Optim += Y_res[k] >= 1
                    Optim += P_load[k] + eff_from_bss*P_from_bss[k] + P_res[k] >= L[k] 
                    Optim += P_load[k] == P_to_hp[k] + P_to_sh[k]
                    Optim += P_load[k] + P_to_bss[k] + P_stnb[k] + P_to_wh[k] <= P[k] + P_res[k]
                    Optim += P_stnb[k] == P_stnb_max
                    Optim += P_to_hp[k] >= (Q_h * (1 - (25 /T_H))) * Y_hp[k]
                    Optim += P_to_hp[k] <= P_hp_max * Y_hp[k]
                    Optim += P_bio[k] <= P_bio_max * Y_bio[k]
                    Optim += P_to_wh[k] <= 0.9*P_max * Y_wh[k]
                    Optim += P_to_sh[k] <= 0.9*P_max * Y_sh[k]
                    Optim += P[k]  <= P_max * Y[k]
                    Optim += P[k]  >= P_min * Y[k]
                    Optim += Y[k] + Y_res[k] >= 0
                    Optim += Y[k] <= 1
                    Optim += P_to_bss[k] <= eff_to_bss * P_max * Y_to_bss[k]
                    Optim += P_from_bss[k] <= eff_from_bss * P_max * Y_from_bss[k]
                    Optim += Y_to_bss[k] + Y_from_bss[k]  <= 1
                    if k == V_steps[0] :                                            
                        Optim += Q_bss[k] == Q_0 + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt
                    else :  
                        Optim += Q_bss[k] == Q_bss[k-1] + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt

                    for k in range(V_steps[0], V_steps[-1]): 
                        Optim += Z[k] >= Y[k + 1] - Y[k] 
                    Optim += Q_bss[V_steps[-1]] == Q_final
                                    
                    ### Solving the problem.
                    status = Optim.solve(GUROBI())


                    ### Optimization status.
                    LpStatus[status]

                    # PRINTING THE LP OPTIMAL SOLUTION.
                    for v in Optim.variables():
                        print(v.name, "=", v.varValue)


                    ### Calculating the optimized fuel comsumption.
                    print("Actual total fuel comsumption:", value(Optim.objective),'g') 
                    print('Optimization done!')

                    ###############################  OPTIMIZATION END ###################################################################
   

    print('#######', mes, ':',str(message.payload.decode('utf-8')),unit,'#######')
    print('=======', str(datetime.now()), '=======')
    print('message topic is : ',message.topic)
    print('message qos is : ', message.qos)
    print('mesaage retain flag = ', message.retain)
    q.put(message)
    print('data_stream:',data_stream)
    print(mes,':', data_stream)   

def on_disconnect(client, userdata, rc):
    if rc != 0:
        print("Unexpected disconnection.")

    client.on_disconnect = on_disconnect

def on_log(client, userdata, level, buf):
    print("log: ",buf)


while not q.empty():
   message = q.get()
   if message is None:
       continue
   print("received from queue",str(message.payload.decode("utf-8")))


###

broker_address='iot.novia.fi'
print('Creating new instance of the client')
client=mqtt.Client() 
client.on_message=on_message #attach function to callback
print("connecting to Novia broker..")

client.on_connect = on_connect
client.username_pw_set(username, password)
client.connect(broker_address, 1883, 60)
sleep(4) # wait
client.loop_stop() #stop the loop

client.loop_start() #start the loop
client.on_log=on_log #printing log information
print("Subscribing to topic", sub_topic)
client.subscribe(sub_topic)
print('returned list:', strg)


def publish(client):
    msg = 0
    pub_topic = 'meteoria/optimizer/gensetControl'
    while True:
        sleep(1)
        result = client.publish(pub_topic, msg)
        # result: [0, 1]
        status = result[0]
        if status == 0:
            print(f"Send `{msg}` to topic `{pub_topic}`")
        else:
            print(f"Failed to send message to topic {pub_topic}")



def run():
    publish(client)


if __name__ == '__main__':
    run()

