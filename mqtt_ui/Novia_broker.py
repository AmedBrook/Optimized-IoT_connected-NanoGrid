import paho.mqtt.client as mqtt #importing the client 
import time #importing time 
from time import sleep
import access_key
from datetime import datetime
from src.functions.fuel_consumption import fuelCon
from src.functions.load_window import lwd 
from queue import Queue
import json

import pandas as pd
import numpy as np
from pulp import *


# Optimizer params 



### Introducing problem parameters.
Q_max = 10                                                    # maximal capacity stored on battery.
Q_0 = 0.1*Q_max                                               # inital capacity stored on battery.
Q_final = 0.2*Q_max                                           # Final capacity stored on the battery. 
eff_to_bss = 0.9                                              # battery charging efficiency.
eff_from_bss = 0.9                                            # battery transfer efficiency. 
P_max = 3000                                                  # max output from gen set A.
P_min = 0                                                     # min output from gen set A.        
dt = 1                                                        # simulation time step dt.
t_max = 10                                                    # time span for simulation = t_max hours.
t = np.atleast_2d(np.arange(0,t_max,dt)).T.conj()             # time scale in hours.
n = len(t)                                                    # number of time steps.
m = 1                                                         # number of Gensets used on the trip, 1 is used.
fc_offset = 190                                               # genset j fuel consumption when no power gnerated (p=0) in g/h.
V_steps = [x for x in range(0,n)]                             # Time steps vector. 
P_pub = [0 for x in range(0,n)] 
V_steps_z = V_steps[:-1]                                      # Time steps vector without the final step. 
Q_h = { x:135000 for x in V_steps}                            # Estimated heat loss when temp drops. 1 kJ/h = 0.0002777778 kW
T_H = {x:21 for x in V_steps}                                 # Inside temperature (°C) (barn temperature). 
S_pv30 = 24                                                   # total solar PV modules surface. 
Ones = {x:1 for x in V_steps}

Irr_list = []
df_Irr = pd.read_csv('Irr_sol.csv')
for i in df_Irr.iloc[-1,:]: 
    Irr_list.append(float(i))
    Irr_sol_dict = dict(zip(V_steps, Irr_list))

Wind_vlct = []
df_vlct = pd.read_csv('Wind_speed.csv')
for i in df_vlct.iloc[-1,:]: 
    Wind_vlct.append(float(i))
    Wind_vlct_dict = dict(zip(V_steps, Wind_vlct))


T_L = []   # Temperature outside
df_temp = pd.read_csv('Air_temp.csv')
for i in df_temp.iloc[-1,:]: 
    T_L.append(float(i))
    T_L_dict = dict(zip(V_steps, T_L))



P_pv30 = {k:Irr_sol_dict[k] * S_pv30 for k in V_steps}        
print('P_pv30 = ',P_pv30)

P_wind = {k:Wind_vlct_dict[k] ** 3 * (6 ** 2) * np.pi *  1.225 * 0.45 * (1/2) for k in V_steps}        # = Irr_sol[k]*S_pv30 for k in V_steps
print('P_wind = ', P_wind)

P_to_hp = {k:(Q_h[k] / Ones[k] / (Ones[k] - T_L_dict[k]) / T_H[k])*10**(-3) for k in V_steps}
print('P_to_hp = ', P_to_hp)


#P_wind = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0}
#P_pv30 = {0:2, 1:1, 2:0.3, 3:0.7, 4:1.5, 5:0.9, 6:0.5, 7:1.2, 8:1.6, 9:1.9}
P_pv60 = {0:0, 1:3, 2:0, 3:0, 4:4, 5:0, 6:1.5, 7:0, 8:0, 9:0}
#P_wind = {k:1/2*V_wind[k]*Cp*rho*math.pi*R**2 for k in V_steps) # Power generated by the wind turbine (cut-out wind speed (kwh).  P = 0.5 Cp ρ π R2 V3
P_pv30_max = 2                                                # (Irr_sol[k]*S_pv30 for k in V_steps)  Maximal power generated by Solar PV modules tilted by 30° (for maximal irradiance (W/m^2).
P_pv30_min = 0                                                # Minimal power generated by Solar PV modules tilted by 30° (at night irradiance = 0 W/m^2).
P_pv60_max = 2                                                # (Irr_sol[k]*S_pv60 for k in V_steps)  Maximal power generated by Solar PV modules tilted by 60° (for maximal irradiance (W/m^2).
P_pv60_min = 0                                                # Minimal power generated by Solar PV modules tilted by 60° (at night irradiance = 0 W/m^2).
P_wind_max = 11                                               # (1/2*V_wind[k]*Cp*rho*math.pi*R**2 for k in V_steps) Maximal power generated by the wind turbine (cut-out wind speed (kwh).  P = 0.5 Cp ρ π R2 V3
P_wind_min = 0	                                              # Minimal power generated by the wind turbine (cut-in wind speed (kwh).
P_hp_max = 1.1                                                # (Q_h / 1 / (1 - T_L[k] / T_H) for k in V_steps) Maximal power transferred to Meteoria barn’s heat pumps (kwh).
P_hp_min = 	0                                                 # Minimal power transferred to Meteoria barn’s heat pumps (kwh).
P_sh_max =  5.1	                                              # Maximal power transferred to the space heater (kwh).
P_sh_min =	0                                                 # Minimal power transferred to the space heater (kwh).
P_bio_max =	1.2                                               # Maximal power generated by biomeiler compost heater (kwh).
P_bio_min =	0                                                 # Minimal power generated by biomeiler compost heater (kwh).
P_wh_max = 6                                                  # Maximal power transferred to water tank heater (kwh).
P_wh_min = 0	                                                # Minimal power transferred to water tank heater (kwh).
P_stnb_max = 3                                                # Maximal standby power to keep essential equipment on standby mode (kwh).
P_stnb_min = 3	                                              # Minimal standby power to keep essential equipment on standby mode (kwh).     
L = lwd (5, 3, 5,                                             # Typical Power requirement window.
                5, 10, 5,
                2, 1.5, 10,
                1.5, 2.5, 30,
                0, 5, 20, 30)       


# Getting the current date and time
q=Queue()
####

username= access_key.username
password= access_key.password

sub_topic1 = 'open/meteoria/solarRadiation'
sub_topic2 = 'open/meteoria/windSpeed'
sub_topic3 = 'open/meteoria/airTemp'
mes1 = 'Irr_sol'
mes2 = 'Wind_speed'
mes3 = 'Air_Temp'

unit1 = 'W/m^2'
unit2 = 'm/s'
unit3 = '°C'


Irr_list = []
df = pd.read_csv('Irr_sol.csv')
for i in df.iloc[-1,:]: 
    Irr_list.append(float(i))
    Irr_sol_dict = dict(zip(V_steps, Irr_list))



# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code "+str(rc))
    client.subscribe([(sub_topic1, 2), (sub_topic2, 2), (sub_topic3, 2)])


data_stream_Irr, data_stream_wind, data_stream_Temp, strg_Irr, strg_wind, strg_Temp = [], [], [], [], [], []
steps=[k for k in range (0,9)]

def on_message(client, userdata, message): 
    
    global data_stream_Irr, data_stream_wind, data_stream_Temp, strg_Irr, strg_wind, strg_Temp, P_pub

    i=0
    if len(data_stream_Irr or data_stream_wind or data_stream_Temp) < 10 :    
       for j in range(0,9): 
        while i < 1 : 
            log = json.loads(message.payload.decode("utf-8"))
            if message.topic == sub_topic1 : 
                data_stream_Irr.append(log)

            elif message.topic == sub_topic2 : 
                data_stream_wind.append(log) 
            
            elif message.topic == sub_topic3 : 
                data_stream_Temp.append(log) 

            i+=1
            j+=1

            if len(data_stream_Irr) == 10 or len(data_stream_wind) == 10 or len(data_stream_Temp) == 10 : 
                strg_Irr = data_stream_Irr
                strg_wind = data_stream_wind
                strg_Temp = data_stream_Temp
                print('returned list', strg_Irr)
                print('returned list', strg_wind)
                print('returned list', strg_Temp)

                ###############################  OPTIMIZATION ###################################################################
                
                Optim = LpProblem('Energy_Opt',LpMinimize)
                
                ### Slope, intercept and maximum fuel bound calculation.
                a_j = (fuelCon(0.9*P_max, P_max) - fuelCon(0.2*P_max, P_max)) /(0.9*P_max) #slope.
                b_j = fuelCon(0.2*P_max, P_max) - a_j*0.2*P_max #Intercept.
                FOC_max = fuelCon(0.9*P_max,P_max) # Max fuel bound.


                ### Setting-up decision Variables.
                Q_bss = LpVariable.dicts("Q_bss", V_steps, lowBound=0.2*Q_max, upBound=Q_max, cat=LpContinuous)  # Battery charge at time step k.
                P_from_bss = LpVariable.dicts("P_from_bss", V_steps, lowBound=P_min, cat=LpContinuous) # Power transfered from the battery to the load.
                #P_pv30 = LpVariable.dicts("P_pv30", V_steps, lowBound=P_pv30_min, upBound=P_pv30_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
                #P_pv60 = LpVariable.dicts("P_pv60", V_steps, lowBound=P_pv60_min, upBound=P_pv60_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
                #P_wind = LpVariable.dicts("P_wind", V_steps, lowBound=P_wind_min, upBound=P_wind_max, cat=LpContinuous) # Power from wind turbine.
                P = LpVariable.dicts("P", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Power generated by the Genset A.
                P_res = LpVariable.dicts("P_res", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Total Power from RES.
                P_load = LpVariable.dicts("P_load", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous) # Power transfered from the Genset A to the load at time step k.
                P_stnb = LpVariable.dicts("P_stnb", V_steps, lowBound=P_stnb_min, upBound=P_stnb_max, cat=LpContinuous) # Standby power.
                P_to_sh = LpVariable.dicts("P_to_sh", V_steps, lowBound=P_sh_min, upBound=.9*P_max, cat=LpContinuous) # Power to space heater (excess heat (kw). 
                P_to_wh = LpVariable.dicts("P_to_wt", V_steps, lowBound=P_wh_min, upBound=.9*P_max, cat=LpContinuous) # Power to water tank heater.
                #P_to_hp = LpVariable.dicts("P_to_hp", V_steps, lowBound=P_hp_min, upBound=.9*P_max, cat=LpContinuous) # Power to heat pumps.
                P_bio	= LpVariable.dicts("P_bio", V_steps, lowBound=P_bio_min, upBound=P_bio_max, cat=LpContinuous) # Power from biomeiler compost heater. 
                Z =  LpVariable.dicts("Z", V_steps_z, lowBound=0, upBound=1, cat=LpInteger) # Aditional cost fuel oil consumption when starting Genset j.
                FOC = LpVariable.dicts("FOC", V_steps, lowBound=0, upBound=FOC_max, cat=LpContinuous) # Fuel oil consumption of genset j.
                P_to_bss =  LpVariable.dicts("P_to_bss", V_steps, lowBound=P_min, cat=LpContinuous) 
                Y_to_bss = LpVariable.dicts("Y_to_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter to charge the battery at time step k. 
                Y_from_bss = LpVariable.dicts("Y_from_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Battery selecter to transfert to the Genset j st time step k.
                Y = LpVariable.dicts("Y", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter : turned on : Y=1, turned off : Y=0.
                Y_bio = LpVariable.dicts("Y_bio", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of biomeiler.
                Y_sh =	LpVariable.dicts("Y_sh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of space heater.
                Y_hp = LpVariable.dicts("Y_hp", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of heat pumps.
                Y_wh = LpVariable.dicts("Y_wh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of water heater.
                Y_wind = LpVariable.dicts("Y_wind", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of wind turbine.
                Y_pv30 = LpVariable.dicts("Y_pv30", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 30°.
                Y_pv60 = LpVariable.dicts("Y_pv60", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 60°.
                Y_res = LpVariable.dicts("Y_res", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state RES.
                Null = LpVariable.dict("Null", V_steps, lowBound=0, upBound=0,cat=LpBinary) # Reference variable

                ### Setting-up the objective function.
                FC = sum(FOC[k] for k in V_steps) * dt/1000  # sum of the fuel oil comsumption for all gensets over all k steps.
                L_added_cost = sum(Z[i] for i in V_steps_z)  # Sum of all of the additional costs including starting costs. 
                Optim += lpSum (FC + L_added_cost), " Minimization fuel oil consumption objective " 
                print(FC)


                ### Setting-up problem constraints.

                for k in V_steps:

                # Fuel oil consumption constraint.
                    Optim += FOC[k] == P[k]*a_j + (b_j - fc_offset)*Y[k]     
                    Optim += P_res[k] == P_pv30[k] + P_pv60[k] + P_wind[k] 
                    Optim += P_res[k] >= P_min * Y_res[k]
                    Optim += Y_res[k] >= 1
                    Optim += P_load[k] + eff_from_bss*P_from_bss[k] + P_res[k] >= L[k] 
                    Optim += P_load[k] == P_to_hp[k] + P_to_sh[k]
                    Optim += P_load[k] + P_to_bss[k] + P_stnb[k] + P_to_wh[k] <= P[k] + P_res[k]
                    Optim += P_stnb[k] == P_stnb_max
                    #Optim += P_to_hp[k] >= (Q_h * (1 - (25 /T_H))) * Y_hp[k]
                    Optim += P_to_hp[k] <= P_hp_max * Y_hp[k]
                    Optim += P_bio[k] <= P_bio_max * Y_bio[k]
                    Optim += P_to_wh[k] <= 0.9*P_max * Y_wh[k]
                    Optim += P_to_sh[k] <= 0.9*P_max * Y_sh[k]
                    Optim += P[k]  <= P_max * Y[k]
                    Optim += P[k]  >= P_min * Y[k]
                    Optim += Y[k] + Y_res[k] >= 0
                    Optim += Y[k] <= 1
                    Optim += P_to_bss[k] <= eff_to_bss * P_max * Y_to_bss[k]
                    Optim += P_from_bss[k] <= eff_from_bss * P_max * Y_from_bss[k]
                    Optim += Y_to_bss[k] + Y_from_bss[k]  <= 1
                    if k == V_steps[0] :                                            
                        Optim += Q_bss[k] == Q_0 + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt
                    else :  
                        Optim += Q_bss[k] == Q_bss[k-1] + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt

                    for k in range(V_steps[0], V_steps[-1]): 
                        Optim += Z[k] >= Y[k + 1] - Y[k] 
                    Optim += Q_bss[V_steps[-1]] == Q_final
                                    
                    ### Solving the problem.
                    status = Optim.solve(GUROBI())


                    ### Optimization status.
                    LpStatus[status]

                    # PRINTING THE LP OPTIMAL SOLUTION.
                    for v in Optim.variables():
                        print(v.name, "=", v.varValue)


                    ### Calculating the optimized fuel comsumption.
                    print("Actual total fuel comsumption:", value(Optim.objective),'g') 
                    print('Optimization completed !')
                    print('##############################################')
                    print('P_pv30 : ', P_pv30)
                    print('P_wind : ', P_wind)
                    print('P_to_hp'  , P_to_hp)
                    print('##############################################')

                    ## Genset published Binnary commands logic 
                    for v in Optim.variables():
                        for i in V_steps:
                            if v.name == ('P_'+ str(i)):
                                if v.varValue == 0: 
                                    P_pub[i] = 0
                                else : 
                                    P_pub[i] = 1
                                    
                    ###############################  OPTIMIZATION END ###################################################################

    else : 

        with open("Irr_sol.csv", "a+") as Irr_sol:
                    mystring_irr = ','.join(map(str,data_stream_Irr))
                    Irr_sol.write("%s" %(mystring_irr)+ "\n")
                    Irr_sol.close()

        data_stream_Irr = []
        i=0
        for j in range(10):
         while i < 1 : 
            log = json.loads(message.payload.decode("utf-8"))
            if message.topic == sub_topic1 : 

                data_stream_Irr.append(log)

            #Irr_sol[j] = data_stream[j] 
            i+=1
            if len(data_stream_Irr) == 10 : 
                strg_Irr=data_stream_Irr
                print('returned list', strg_Irr)


                
        with open("Wind_speed.csv", "a+") as wind_speed:
                    mystring_wind = ','.join(map(str,data_stream_wind))
                    wind_speed.write("%s" %(mystring_wind)+ "\n")
                    wind_speed.close()
        
        data_stream_wind = []
        i=0
        for j in range(10):
         while i < 1 : 
            log = json.loads(message.payload.decode("utf-8"))
            if message.topic == sub_topic2 : 

                data_stream_wind.append(log)

            i+=1
            if len(data_stream_wind) == 10:  
                strg_wind=data_stream_wind
                print('returned list:', strg_wind)



        with open("Air_temp.csv", "a+") as Air_temp:
            mystring_temp = ','.join(map(str,data_stream_Temp))
            Air_temp.write("%s" %(mystring_temp)+ "\n")
            Air_temp.close()
        
        data_stream_Temp = []
        i=0
        for j in range(10):
         while i < 1 : 
            log = json.loads(message.payload.decode("utf-8"))
            if message.topic == sub_topic3 : 

                data_stream_Temp.append(log)

            i+=1
            if len(data_stream_Temp) == 10:  
                strg_Temp=data_stream_Temp
                print('returned list:', strg_Temp)       
                
                ###############################  OPTIMIZATION START ###################################################################

                Optim = LpProblem('Energy_Opt',LpMinimize)

                ### Slope, intercept and maximum fuel bound calculation.
                a_j = (fuelCon(0.9*P_max, P_max) - fuelCon(0.2*P_max, P_max)) /(0.9*P_max) #slope.
                b_j = fuelCon(0.2*P_max, P_max) - a_j*0.2*P_max #Intercept.
                FOC_max = fuelCon(0.9*P_max,P_max) # Max fuel bound.


                ### Setting-up decision Variables.
                Q_bss = LpVariable.dicts("Q_bss", V_steps, lowBound=0.2*Q_max, upBound=Q_max, cat=LpContinuous)  # Battery charge at time step k.
                P_from_bss = LpVariable.dicts("P_from_bss", V_steps, lowBound=P_min, cat=LpContinuous) # Power transfered from the battery to the load.
                #P_pv30 = LpVariable.dicts("P_pv30", V_steps, lowBound=P_pv30_min, upBound=P_pv30_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
                #P_pv60 = LpVariable.dicts("P_pv60", V_steps, lowBound=P_pv60_min, upBound=P_pv60_max, cat=LpContinuous) # Power from solar PV modules tilted by 30° .
                #P_wind = LpVariable.dicts("P_wind", V_steps, lowBound=P_wind_min, upBound=P_wind_max, cat=LpContinuous) # Power from wind turbine.
                P = LpVariable.dicts("P", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Power generated by the Genset A.
                P_res = LpVariable.dicts("P_res", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous)  # Total Power from RES.
                P_load = LpVariable.dicts("P_load", V_steps, lowBound=P_min, upBound=0.9*P_max, cat=LpContinuous) # Power transfered from the Genset A to the load at time step k.
                P_stnb = LpVariable.dicts("P_stnb", V_steps, lowBound=P_stnb_min, upBound=P_stnb_max, cat=LpContinuous) # Standby power.
                P_to_sh = LpVariable.dicts("P_to_sh", V_steps, lowBound=P_sh_min, upBound=.9*P_max, cat=LpContinuous) # Power to space heater (excess heat (kw). 
                P_to_wh = LpVariable.dicts("P_to_wt", V_steps, lowBound=P_wh_min, upBound=.9*P_max, cat=LpContinuous) # Power to water tank heater.
                #P_to_hp = LpVariable.dicts("P_to_hp", V_steps, lowBound=P_hp_min, upBound=.9*P_max, cat=LpContinuous) # Power to heat pumps.
                P_bio	= LpVariable.dicts("P_bio", V_steps, lowBound=P_bio_min, upBound=P_bio_max, cat=LpContinuous) # Power from biomeiler compost heater. 
                Z =  LpVariable.dicts("Z", V_steps_z, lowBound=0, upBound=1, cat=LpInteger) # Aditional cost fuel oil consumption when starting Genset j.
                FOC = LpVariable.dicts("FOC", V_steps, lowBound=0, upBound=FOC_max, cat=LpContinuous) # Fuel oil consumption of genset j.
                P_to_bss =  LpVariable.dicts("P_to_bss", V_steps, lowBound=P_min, cat=LpContinuous) 
                Y_to_bss = LpVariable.dicts("Y_to_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter to charge the battery at time step k. 
                Y_from_bss = LpVariable.dicts("Y_from_bss", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Battery selecter to transfert to the Genset j st time step k.
                Y = LpVariable.dicts("Y", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Genset selecter : turned on : Y=1, turned off : Y=0.
                Y_bio = LpVariable.dicts("Y_bio", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of biomeiler.
                Y_sh =	LpVariable.dicts("Y_sh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of space heater.
                Y_hp = LpVariable.dicts("Y_hp", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of heat pumps.
                Y_wh = LpVariable.dicts("Y_wh", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of water heater.
                Y_wind = LpVariable.dicts("Y_wind", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of wind turbine.
                Y_pv30 = LpVariable.dicts("Y_pv30", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 30°.
                Y_pv60 = LpVariable.dicts("Y_pv60", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state of solar panels tilted by 60°.
                Y_res = LpVariable.dicts("Y_res", V_steps, lowBound=0, upBound=1, cat=LpBinary) # Binary state RES.
                Null = LpVariable.dict("Null", V_steps, lowBound=0, upBound=0,cat=LpBinary) # Reference variable

                ### Setting-up the objective function.
                FC = sum(FOC[k] for k in V_steps) * dt/1000  # sum of the fuel oil comsumption for all gensets over all k steps.
                L_added_cost = sum(Z[i] for i in V_steps_z)  # Sum of all of the additional costs including starting costs. 
                Optim += lpSum (FC + L_added_cost), " Minimization fuel oil consumption objective " 
                print(FC)


                ### Setting-up problem constraints.

                for k in V_steps:

                # Fuel oil consumption constraint.
                    Optim += FOC[k] == P[k]*a_j + (b_j - fc_offset)*Y[k]     
                    Optim += P_res[k] == P_pv30[k] + P_pv60[k] + P_wind[k] 
                    Optim += P_res[k] >= P_min * Y_res[k]
                    Optim += Y_res[k] >= 1
                    Optim += P_load[k] + eff_from_bss*P_from_bss[k] + P_res[k] >= L[k] 
                    Optim += P_load[k] == P_to_hp[k] + P_to_sh[k]
                    Optim += P_load[k] + P_to_bss[k] + P_stnb[k] + P_to_wh[k] <= P[k] + P_res[k]
                    Optim += P_stnb[k] == P_stnb_max
                    #Optim += P_to_hp[k] >= (Q_h * (1 - (25 /T_H))) * Y_hp[k]
                    Optim += P_to_hp[k] <= P_hp_max * Y_hp[k]
                    Optim += P_bio[k] <= P_bio_max * Y_bio[k]
                    Optim += P_to_wh[k] <= 0.9*P_max * Y_wh[k]
                    Optim += P_to_sh[k] <= 0.9*P_max * Y_sh[k]
                    Optim += P[k]  <= P_max * Y[k]
                    Optim += P[k]  >= P_min * Y[k]
                    Optim += Y[k] + Y_res[k] >= 0
                    Optim += Y[k] <= 1
                    Optim += P_to_bss[k] <= eff_to_bss * P_max * Y_to_bss[k]
                    Optim += P_from_bss[k] <= eff_from_bss * P_max * Y_from_bss[k]
                    Optim += Y_to_bss[k] + Y_from_bss[k]  <= 1
                    if k == V_steps[0] :                                            
                        Optim += Q_bss[k] == Q_0 + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt
                    else :  
                        Optim += Q_bss[k] == Q_bss[k-1] + eff_to_bss*P_to_bss[k]*dt - P_from_bss[k]*dt

                    for k in range(V_steps[0], V_steps[-1]): 
                        Optim += Z[k] >= Y[k + 1] - Y[k] 
                    Optim += Q_bss[V_steps[-1]] == Q_final
                                    
                    ### Solving the problem.
                    status = Optim.solve(GUROBI())


                    ### Optimization status.
                    LpStatus[status]

                    # PRINTING THE LP OPTIMAL SOLUTION.
                    for v in Optim.variables():
                        print(v.name, "=", v.varValue)


                    ### Calculating the optimized fuel comsumption.
                    print("Actual total fuel comsumption:", value(Optim.objective),'g') 
                    print('Optimization done!')
                    print('##############################################')
                    print('P_pv30 : ', P_pv30)
                    print('P_wind : ', P_wind)
                    print('P_to_hp'  , P_to_hp)
                    print('##############################################')

                    ## Genset published Binnary commands logic 
                    for v in Optim.variables():
                        for i in V_steps:
                            if v.name == ('P_'+ str(i)):
                                if v.varValue == 0: 
                                    P_pub[i] = 0
                                else : 
                                    P_pub[i] = 1
                                    
                    ###############################  OPTIMIZATION END ###################################################################
   

    print('#######', mes1, ':',str(message.payload.decode('utf-8')),unit1,'#######')
    print('=======', str(datetime.now()), '=======')
    print('message topic is : ',message.topic)
    print('message qos is : ', message.qos)
    print('mesaage retain flag = ', message.retain)
    q.put(message)
    print('data_stream:',data_stream_Irr)
    print(mes1,':', data_stream_Irr)   

    print('#######', mes2, ':',str(message.payload.decode('utf-8')),unit2,'#######')
    print('=======', str(datetime.now()), '=======')
    print('message topic is : ',message.topic)
    print('message qos is : ', message.qos)
    print('mesaage retain flag = ', message.retain)
    q.put(message)
    print('data_stream:',data_stream_wind)
    print(mes2,':', data_stream_wind)   
    
    print('#######', mes3, ':',str(message.payload.decode('utf-8')),unit2,'#######')
    print('=======', str(datetime.now()), '=======')
    print('message topic is : ',message.topic)
    print('message qos is : ', message.qos)
    print('mesaage retain flag = ', message.retain)
    q.put(message)
    print('data_stream:',data_stream_Temp)
    print(mes3,':', data_stream_Temp)   


'''
def on_disconnect(client, userdata, rc):
    if rc != 0:
        print("Unexpected disconnection.")

    client.on_disconnect = on_disconnect
'''

def on_log(client, userdata, level, buf):
    print("log: ",buf)


while not q.empty():
   message = q.get()
   if message is None:
       continue
   print("received from queue",str(message.payload.decode("utf-8")))


###

broker_address='iot.novia.fi'
print('Creating new instance of the client')
client=mqtt.Client() 
client.on_message=on_message #attach function to callback
print("connecting to Novia broker..")

client.on_connect = on_connect
client.username_pw_set(username, password)
client.connect(broker_address, 1883, 60)
sleep(4) # wait
client.loop_stop() #stop the loop

client.loop_start() #start the loop
client.on_log=on_log #printing log information
print("Subscribing to topic", sub_topic1)
print("Subscribing to topic", sub_topic2)
print("Subscribing to topic", sub_topic3)
client.subscribe([(sub_topic1, 2),(sub_topic2, 2), (sub_topic3, 2)])
#client.subscribe(sub_topic2)
print('returned list:', strg_Irr)
print('returned list:', strg_wind)
print('returned list:', strg_Temp)


def publish(client):
    for i in P_pub: 
        msg = P_pub[i]
    pub_topic = 'meteoria/optimizer/gensetControl'
    
    while True:
        sleep(1)
        result = client.publish(pub_topic, msg)
        # result: [0, 1]
        status = result[0]
        if status == 0:
            print(f"Send `{msg}` to topic `{pub_topic}`")
        else:
            print(f"Failed to send message to topic {pub_topic}")



def run():
    publish(client)


if __name__ == '__main__':
    run()

